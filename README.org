#+TITLE: Sexpresso

Sexpresso is c++ centric [[https://en.wikipedia.org/wiki/S-expression][s-expression]] parser library. It uses value types and
move semantics and thus manages to completely avoid calling new/delete, so it's probably
free from memory leaks!

Sexpresso aims to be very simple, nodes are parsed either as s-expressions or strings, even
a number would be parsed a string, so if you expect a node to be a number, please convert the
string to a number!

* How to use
** Parsing

Sexpresso does not use any header guard because they are messy and ugly and add extra processing
to the pre-processor. So instead you'll have to copy the lines from the header and uncomment them
for the dependency includes from the C++ standard library (see [[http://doc.cat-v.org/bell_labs/pikestyle][pike style]]). After you've done that
you are in smooth sailing land. The lines you wanna copy look something like this in ~sexpresso.hpp~:

#+BEGIN_SRC c++
// dependencies (copy below lines and uncomment)
// #include <vector>
// #include <string>
// #include <cstdint>
// #include "sexpresso.hpp"
#+END_SRC

After that you can move onward!

#+BEGIN_SRC c++
auto parsetree = sexpresso::parse(mysexpr);
#+END_SRC

This code will parse the ~std::string~ in mysexpr and return a Sexp struct value.
There are two main things you can do with this value you can:

1. Turn it back to a string with ~parsetree.toString()~
2. Query it using ~parsetree.getChildByPath("path/to/node")~

Number 2 might be slightly confusing, how does it follow the path? Well if you've ever used lisp,
you know that the /command/ in an s-expression is the first element. The same thing here determines
where it goes looking for values. For example if you have an s-expression such as

#+BEGIN_SRC lisp
(my-values (sweet baby jesus) (hi mom) just-a-thing)
#+END_SRC

You can query it like:

#+BEGIN_SRC c++
auto sub = parsetree.getChildByPath("my-values/sweet");
#+END_SRC

and

#+BEGIN_SRC c++
auto sub = parsetree.getChildByPath("my-values/hi");
#+END_SRC

Note that you get the sexpr node that *contains* the value you
were looking for as its first value. The sexpr then simply holds an ~std::vector~ of all the sub-values.
However, it might not always use the vector, if it's simply a string value like ~just-a-thing~ in the
above example, then the vector will be empty, and you need to access the string value instead.

#+BEGIN_SRC c++
if(sub.isSexp()) {
  std::cout << sub->value.sexpr[1];
} else {
  std::cout << sub->value.str;
}

// or

switch(sub->kind) {
case sexpresso::SexpValueKind::SEXP:
  std::cout << sub->value.sexpr[1];
  break;
case sexpresso::SexpValueKind::STRING:
  std::cout << sub->value.str;
}
#+END_SRC

*WARNING* Be *REALLY* careful that your query result does not exceed the lifetime of
the parse tree:

#+BEGIN_SRC c++
Sexp* sub;
{
auto sexp = sexpresso::parse(mysexpr);
sub = sexp.getChildByPath("my-values/just-a-thing")
} // sexp gets destroyed here
cout << sub.toString(); // BAD!
#+END_SRC

** Serializing
Sexp structs have an ~addChild~ method that takes a Sexp method. Furthermore, Sexp has a constructor
that takes a std::string, so this should make it really easy to build your own Sexp objects from code that
you can serialize with ~toString~.

#+BEGIN_SRC c++
auto myvalues = sexpresso::Sexp{"my-values"};

auto sweet = sexpresso::Sexp{"sweet"};
sweet.addChild("baby");
sweet.addChild("jesus");

auto hi = sexpresso::Sexp{"hi"};
hi.addChild("mom");

auto justathing = sexpresso::Sexp{"just-a-thing"};

auto myvaluesholder = sexpresso::Sexp{};
myvaluesholder.addChild(std::move(myvalues));
myvaluesholder.addChild(std::move(sweet));
myvaluesholder.addChild(std::move(hi));
myvaluesholder.addChild(std::move(justathing));

auto sexp = sexpresso::Sexp{};
sexp.addChild(myvaluesholder);

// sexp should now hold the same s-expression we wrote in text earlier
std::cout << sexp.toString();
#+END_SRC

* FAQ
** Why should I use s-expressions
because they are more elegant and simple than XML or JSON. Much less work required to parse. And they look nice! (subjective)

* Future direction
Make it a header-only library instead perhaps?
